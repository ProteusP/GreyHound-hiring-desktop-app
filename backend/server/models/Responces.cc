/**
 *
 *  Responces.cc
 *  DO NOT EDIT. This file is generated by drogon_ctl
 *
 */

#include "Responces.h"
#include <drogon/utils/Utilities.h>
#include <string>

using namespace drogon;
using namespace drogon::orm;
using namespace drogon_model::default_db;

const std::string Responces::Cols::_candidate_id = "candidate_id";
const std::string Responces::Cols::_vacancy_id = "vacancy_id";
const std::string Responces::Cols::_employer_id = "employer_id";
const std::string Responces::Cols::_status = "status";
const std::string Responces::Cols::_created_at = "created_at";
const std::vector<std::string> Responces::primaryKeyName = {"candidate_id",
                                                            "vacancy_id"};
const bool Responces::hasPrimaryKey = true;
const std::string Responces::tableName = "responces";

const std::vector<typename Responces::MetaData> Responces::metaData_ = {
    {"candidate_id", "int32_t", "int", 4, 0, 1, 1},
    {"vacancy_id", "int32_t", "int", 4, 0, 1, 1},
    {"employer_id", "int32_t", "int", 4, 0, 0, 1},
    {"status", "std::string", "varchar(50)", 50, 0, 0, 0},
    {"created_at", "::trantor::Date", "timestamp", 0, 0, 0, 0}};
const std::string &Responces::getColumnName(size_t index) noexcept(false) {
    assert(index < metaData_.size());
    return metaData_[index].colName_;
}
Responces::Responces(const Row &r, const ssize_t indexOffset) noexcept {
    if (indexOffset < 0) {
        if (!r["candidate_id"].isNull()) {
            candidateId_ =
                std::make_shared<int32_t>(r["candidate_id"].as<int32_t>());
        }
        if (!r["vacancy_id"].isNull()) {
            vacancyId_ =
                std::make_shared<int32_t>(r["vacancy_id"].as<int32_t>());
        }
        if (!r["employer_id"].isNull()) {
            employerId_ =
                std::make_shared<int32_t>(r["employer_id"].as<int32_t>());
        }
        if (!r["status"].isNull()) {
            status_ =
                std::make_shared<std::string>(r["status"].as<std::string>());
        }
        if (!r["created_at"].isNull()) {
            auto timeStr = r["created_at"].as<std::string>();
            struct tm stm;
            memset(&stm, 0, sizeof(stm));
            auto p = strptime(timeStr.c_str(), "%Y-%m-%d %H:%M:%S", &stm);
            time_t t = mktime(&stm);
            size_t decimalNum = 0;
            if (p) {
                if (*p == '.') {
                    std::string decimals(p + 1, &timeStr[timeStr.length()]);
                    while (decimals.length() < 6) {
                        decimals += "0";
                    }
                    decimalNum = (size_t)atol(decimals.c_str());
                }
                createdAt_ =
                    std::make_shared<::trantor::Date>(t * 1000000 + decimalNum);
            }
        }
    } else {
        size_t offset = (size_t)indexOffset;
        if (offset + 5 > r.size()) {
            LOG_FATAL << "Invalid SQL result for this model";
            return;
        }
        size_t index;
        index = offset + 0;
        if (!r[index].isNull()) {
            candidateId_ = std::make_shared<int32_t>(r[index].as<int32_t>());
        }
        index = offset + 1;
        if (!r[index].isNull()) {
            vacancyId_ = std::make_shared<int32_t>(r[index].as<int32_t>());
        }
        index = offset + 2;
        if (!r[index].isNull()) {
            employerId_ = std::make_shared<int32_t>(r[index].as<int32_t>());
        }
        index = offset + 3;
        if (!r[index].isNull()) {
            status_ = std::make_shared<std::string>(r[index].as<std::string>());
        }
        index = offset + 4;
        if (!r[index].isNull()) {
            auto timeStr = r[index].as<std::string>();
            struct tm stm;
            memset(&stm, 0, sizeof(stm));
            auto p = strptime(timeStr.c_str(), "%Y-%m-%d %H:%M:%S", &stm);
            time_t t = mktime(&stm);
            size_t decimalNum = 0;
            if (p) {
                if (*p == '.') {
                    std::string decimals(p + 1, &timeStr[timeStr.length()]);
                    while (decimals.length() < 6) {
                        decimals += "0";
                    }
                    decimalNum = (size_t)atol(decimals.c_str());
                }
                createdAt_ =
                    std::make_shared<::trantor::Date>(t * 1000000 + decimalNum);
            }
        }
    }
}

Responces::Responces(
    const Json::Value &pJson,
    const std::vector<std::string> &pMasqueradingVector) noexcept(false) {
    if (pMasqueradingVector.size() != 5) {
        LOG_ERROR << "Bad masquerading vector";
        return;
    }
    if (!pMasqueradingVector[0].empty() &&
        pJson.isMember(pMasqueradingVector[0])) {
        dirtyFlag_[0] = true;
        if (!pJson[pMasqueradingVector[0]].isNull()) {
            candidateId_ = std::make_shared<int32_t>(
                (int32_t)pJson[pMasqueradingVector[0]].asInt64());
        }
    }
    if (!pMasqueradingVector[1].empty() &&
        pJson.isMember(pMasqueradingVector[1])) {
        dirtyFlag_[1] = true;
        if (!pJson[pMasqueradingVector[1]].isNull()) {
            vacancyId_ = std::make_shared<int32_t>(
                (int32_t)pJson[pMasqueradingVector[1]].asInt64());
        }
    }
    if (!pMasqueradingVector[2].empty() &&
        pJson.isMember(pMasqueradingVector[2])) {
        dirtyFlag_[2] = true;
        if (!pJson[pMasqueradingVector[2]].isNull()) {
            employerId_ = std::make_shared<int32_t>(
                (int32_t)pJson[pMasqueradingVector[2]].asInt64());
        }
    }
    if (!pMasqueradingVector[3].empty() &&
        pJson.isMember(pMasqueradingVector[3])) {
        dirtyFlag_[3] = true;
        if (!pJson[pMasqueradingVector[3]].isNull()) {
            status_ = std::make_shared<std::string>(
                pJson[pMasqueradingVector[3]].asString());
        }
    }
    if (!pMasqueradingVector[4].empty() &&
        pJson.isMember(pMasqueradingVector[4])) {
        dirtyFlag_[4] = true;
        if (!pJson[pMasqueradingVector[4]].isNull()) {
            auto timeStr = pJson[pMasqueradingVector[4]].asString();
            struct tm stm;
            memset(&stm, 0, sizeof(stm));
            auto p = strptime(timeStr.c_str(), "%Y-%m-%d %H:%M:%S", &stm);
            time_t t = mktime(&stm);
            size_t decimalNum = 0;
            if (p) {
                if (*p == '.') {
                    std::string decimals(p + 1, &timeStr[timeStr.length()]);
                    while (decimals.length() < 6) {
                        decimals += "0";
                    }
                    decimalNum = (size_t)atol(decimals.c_str());
                }
                createdAt_ =
                    std::make_shared<::trantor::Date>(t * 1000000 + decimalNum);
            }
        }
    }
}

Responces::Responces(const Json::Value &pJson) noexcept(false) {
    if (pJson.isMember("candidate_id")) {
        dirtyFlag_[0] = true;
        if (!pJson["candidate_id"].isNull()) {
            candidateId_ = std::make_shared<int32_t>(
                (int32_t)pJson["candidate_id"].asInt64());
        }
    }
    if (pJson.isMember("vacancy_id")) {
        dirtyFlag_[1] = true;
        if (!pJson["vacancy_id"].isNull()) {
            vacancyId_ = std::make_shared<int32_t>(
                (int32_t)pJson["vacancy_id"].asInt64());
        }
    }
    if (pJson.isMember("employer_id")) {
        dirtyFlag_[2] = true;
        if (!pJson["employer_id"].isNull()) {
            employerId_ = std::make_shared<int32_t>(
                (int32_t)pJson["employer_id"].asInt64());
        }
    }
    if (pJson.isMember("status")) {
        dirtyFlag_[3] = true;
        if (!pJson["status"].isNull()) {
            status_ = std::make_shared<std::string>(pJson["status"].asString());
        }
    }
    if (pJson.isMember("created_at")) {
        dirtyFlag_[4] = true;
        if (!pJson["created_at"].isNull()) {
            auto timeStr = pJson["created_at"].asString();
            struct tm stm;
            memset(&stm, 0, sizeof(stm));
            auto p = strptime(timeStr.c_str(), "%Y-%m-%d %H:%M:%S", &stm);
            time_t t = mktime(&stm);
            size_t decimalNum = 0;
            if (p) {
                if (*p == '.') {
                    std::string decimals(p + 1, &timeStr[timeStr.length()]);
                    while (decimals.length() < 6) {
                        decimals += "0";
                    }
                    decimalNum = (size_t)atol(decimals.c_str());
                }
                createdAt_ =
                    std::make_shared<::trantor::Date>(t * 1000000 + decimalNum);
            }
        }
    }
}

void Responces::updateByMasqueradedJson(
    const Json::Value &pJson,
    const std::vector<std::string> &pMasqueradingVector) noexcept(false) {
    if (pMasqueradingVector.size() != 5) {
        LOG_ERROR << "Bad masquerading vector";
        return;
    }
    if (!pMasqueradingVector[0].empty() &&
        pJson.isMember(pMasqueradingVector[0])) {
        if (!pJson[pMasqueradingVector[0]].isNull()) {
            candidateId_ = std::make_shared<int32_t>(
                (int32_t)pJson[pMasqueradingVector[0]].asInt64());
        }
    }
    if (!pMasqueradingVector[1].empty() &&
        pJson.isMember(pMasqueradingVector[1])) {
        if (!pJson[pMasqueradingVector[1]].isNull()) {
            vacancyId_ = std::make_shared<int32_t>(
                (int32_t)pJson[pMasqueradingVector[1]].asInt64());
        }
    }
    if (!pMasqueradingVector[2].empty() &&
        pJson.isMember(pMasqueradingVector[2])) {
        dirtyFlag_[2] = true;
        if (!pJson[pMasqueradingVector[2]].isNull()) {
            employerId_ = std::make_shared<int32_t>(
                (int32_t)pJson[pMasqueradingVector[2]].asInt64());
        }
    }
    if (!pMasqueradingVector[3].empty() &&
        pJson.isMember(pMasqueradingVector[3])) {
        dirtyFlag_[3] = true;
        if (!pJson[pMasqueradingVector[3]].isNull()) {
            status_ = std::make_shared<std::string>(
                pJson[pMasqueradingVector[3]].asString());
        }
    }
    if (!pMasqueradingVector[4].empty() &&
        pJson.isMember(pMasqueradingVector[4])) {
        dirtyFlag_[4] = true;
        if (!pJson[pMasqueradingVector[4]].isNull()) {
            auto timeStr = pJson[pMasqueradingVector[4]].asString();
            struct tm stm;
            memset(&stm, 0, sizeof(stm));
            auto p = strptime(timeStr.c_str(), "%Y-%m-%d %H:%M:%S", &stm);
            time_t t = mktime(&stm);
            size_t decimalNum = 0;
            if (p) {
                if (*p == '.') {
                    std::string decimals(p + 1, &timeStr[timeStr.length()]);
                    while (decimals.length() < 6) {
                        decimals += "0";
                    }
                    decimalNum = (size_t)atol(decimals.c_str());
                }
                createdAt_ =
                    std::make_shared<::trantor::Date>(t * 1000000 + decimalNum);
            }
        }
    }
}

void Responces::updateByJson(const Json::Value &pJson) noexcept(false) {
    if (pJson.isMember("candidate_id")) {
        if (!pJson["candidate_id"].isNull()) {
            candidateId_ = std::make_shared<int32_t>(
                (int32_t)pJson["candidate_id"].asInt64());
        }
    }
    if (pJson.isMember("vacancy_id")) {
        if (!pJson["vacancy_id"].isNull()) {
            vacancyId_ = std::make_shared<int32_t>(
                (int32_t)pJson["vacancy_id"].asInt64());
        }
    }
    if (pJson.isMember("employer_id")) {
        dirtyFlag_[2] = true;
        if (!pJson["employer_id"].isNull()) {
            employerId_ = std::make_shared<int32_t>(
                (int32_t)pJson["employer_id"].asInt64());
        }
    }
    if (pJson.isMember("status")) {
        dirtyFlag_[3] = true;
        if (!pJson["status"].isNull()) {
            status_ = std::make_shared<std::string>(pJson["status"].asString());
        }
    }
    if (pJson.isMember("created_at")) {
        dirtyFlag_[4] = true;
        if (!pJson["created_at"].isNull()) {
            auto timeStr = pJson["created_at"].asString();
            struct tm stm;
            memset(&stm, 0, sizeof(stm));
            auto p = strptime(timeStr.c_str(), "%Y-%m-%d %H:%M:%S", &stm);
            time_t t = mktime(&stm);
            size_t decimalNum = 0;
            if (p) {
                if (*p == '.') {
                    std::string decimals(p + 1, &timeStr[timeStr.length()]);
                    while (decimals.length() < 6) {
                        decimals += "0";
                    }
                    decimalNum = (size_t)atol(decimals.c_str());
                }
                createdAt_ =
                    std::make_shared<::trantor::Date>(t * 1000000 + decimalNum);
            }
        }
    }
}

const int32_t &Responces::getValueOfCandidateId() const noexcept {
    static const int32_t defaultValue = int32_t();
    if (candidateId_)
        return *candidateId_;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Responces::getCandidateId() const noexcept {
    return candidateId_;
}
void Responces::setCandidateId(const int32_t &pCandidateId) noexcept {
    candidateId_ = std::make_shared<int32_t>(pCandidateId);
    dirtyFlag_[0] = true;
}

const int32_t &Responces::getValueOfVacancyId() const noexcept {
    static const int32_t defaultValue = int32_t();
    if (vacancyId_)
        return *vacancyId_;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Responces::getVacancyId() const noexcept {
    return vacancyId_;
}
void Responces::setVacancyId(const int32_t &pVacancyId) noexcept {
    vacancyId_ = std::make_shared<int32_t>(pVacancyId);
    dirtyFlag_[1] = true;
}

const int32_t &Responces::getValueOfEmployerId() const noexcept {
    static const int32_t defaultValue = int32_t();
    if (employerId_)
        return *employerId_;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Responces::getEmployerId() const noexcept {
    return employerId_;
}
void Responces::setEmployerId(const int32_t &pEmployerId) noexcept {
    employerId_ = std::make_shared<int32_t>(pEmployerId);
    dirtyFlag_[2] = true;
}

const std::string &Responces::getValueOfStatus() const noexcept {
    static const std::string defaultValue = std::string();
    if (status_)
        return *status_;
    return defaultValue;
}
const std::shared_ptr<std::string> &Responces::getStatus() const noexcept {
    return status_;
}
void Responces::setStatus(const std::string &pStatus) noexcept {
    status_ = std::make_shared<std::string>(pStatus);
    dirtyFlag_[3] = true;
}
void Responces::setStatus(std::string &&pStatus) noexcept {
    status_ = std::make_shared<std::string>(std::move(pStatus));
    dirtyFlag_[3] = true;
}
void Responces::setStatusToNull() noexcept {
    status_.reset();
    dirtyFlag_[3] = true;
}

const ::trantor::Date &Responces::getValueOfCreatedAt() const noexcept {
    static const ::trantor::Date defaultValue = ::trantor::Date();
    if (createdAt_)
        return *createdAt_;
    return defaultValue;
}
const std::shared_ptr<::trantor::Date> &
Responces::getCreatedAt() const noexcept {
    return createdAt_;
}
void Responces::setCreatedAt(const ::trantor::Date &pCreatedAt) noexcept {
    createdAt_ = std::make_shared<::trantor::Date>(pCreatedAt);
    dirtyFlag_[4] = true;
}
void Responces::setCreatedAtToNull() noexcept {
    createdAt_.reset();
    dirtyFlag_[4] = true;
}

void Responces::updateId(const uint64_t id) {}
typename Responces::PrimaryKeyType Responces::getPrimaryKey() const {
    return std::make_tuple(*candidateId_, *vacancyId_);
}

const std::vector<std::string> &Responces::insertColumns() noexcept {
    static const std::vector<std::string> inCols = {
        "candidate_id", "vacancy_id", "employer_id", "status", "created_at"};
    return inCols;
}

void Responces::outputArgs(drogon::orm::internal::SqlBinder &binder) const {
    if (dirtyFlag_[0]) {
        if (getCandidateId()) {
            binder << getValueOfCandidateId();
        } else {
            binder << nullptr;
        }
    }
    if (dirtyFlag_[1]) {
        if (getVacancyId()) {
            binder << getValueOfVacancyId();
        } else {
            binder << nullptr;
        }
    }
    if (dirtyFlag_[2]) {
        if (getEmployerId()) {
            binder << getValueOfEmployerId();
        } else {
            binder << nullptr;
        }
    }
    if (dirtyFlag_[3]) {
        if (getStatus()) {
            binder << getValueOfStatus();
        } else {
            binder << nullptr;
        }
    }
    if (dirtyFlag_[4]) {
        if (getCreatedAt()) {
            binder << getValueOfCreatedAt();
        } else {
            binder << nullptr;
        }
    }
}

const std::vector<std::string> Responces::updateColumns() const {
    std::vector<std::string> ret;
    if (dirtyFlag_[0]) {
        ret.push_back(getColumnName(0));
    }
    if (dirtyFlag_[1]) {
        ret.push_back(getColumnName(1));
    }
    if (dirtyFlag_[2]) {
        ret.push_back(getColumnName(2));
    }
    if (dirtyFlag_[3]) {
        ret.push_back(getColumnName(3));
    }
    if (dirtyFlag_[4]) {
        ret.push_back(getColumnName(4));
    }
    return ret;
}

void Responces::updateArgs(drogon::orm::internal::SqlBinder &binder) const {
    if (dirtyFlag_[0]) {
        if (getCandidateId()) {
            binder << getValueOfCandidateId();
        } else {
            binder << nullptr;
        }
    }
    if (dirtyFlag_[1]) {
        if (getVacancyId()) {
            binder << getValueOfVacancyId();
        } else {
            binder << nullptr;
        }
    }
    if (dirtyFlag_[2]) {
        if (getEmployerId()) {
            binder << getValueOfEmployerId();
        } else {
            binder << nullptr;
        }
    }
    if (dirtyFlag_[3]) {
        if (getStatus()) {
            binder << getValueOfStatus();
        } else {
            binder << nullptr;
        }
    }
    if (dirtyFlag_[4]) {
        if (getCreatedAt()) {
            binder << getValueOfCreatedAt();
        } else {
            binder << nullptr;
        }
    }
}
Json::Value Responces::toJson() const {
    Json::Value ret;
    if (getCandidateId()) {
        ret["candidate_id"] = getValueOfCandidateId();
    } else {
        ret["candidate_id"] = Json::Value();
    }
    if (getVacancyId()) {
        ret["vacancy_id"] = getValueOfVacancyId();
    } else {
        ret["vacancy_id"] = Json::Value();
    }
    if (getEmployerId()) {
        ret["employer_id"] = getValueOfEmployerId();
    } else {
        ret["employer_id"] = Json::Value();
    }
    if (getStatus()) {
        ret["status"] = getValueOfStatus();
    } else {
        ret["status"] = Json::Value();
    }
    if (getCreatedAt()) {
        ret["created_at"] = getCreatedAt()->toDbStringLocal();
    } else {
        ret["created_at"] = Json::Value();
    }
    return ret;
}

Json::Value Responces::toMasqueradedJson(
    const std::vector<std::string> &pMasqueradingVector) const {
    Json::Value ret;
    if (pMasqueradingVector.size() == 5) {
        if (!pMasqueradingVector[0].empty()) {
            if (getCandidateId()) {
                ret[pMasqueradingVector[0]] = getValueOfCandidateId();
            } else {
                ret[pMasqueradingVector[0]] = Json::Value();
            }
        }
        if (!pMasqueradingVector[1].empty()) {
            if (getVacancyId()) {
                ret[pMasqueradingVector[1]] = getValueOfVacancyId();
            } else {
                ret[pMasqueradingVector[1]] = Json::Value();
            }
        }
        if (!pMasqueradingVector[2].empty()) {
            if (getEmployerId()) {
                ret[pMasqueradingVector[2]] = getValueOfEmployerId();
            } else {
                ret[pMasqueradingVector[2]] = Json::Value();
            }
        }
        if (!pMasqueradingVector[3].empty()) {
            if (getStatus()) {
                ret[pMasqueradingVector[3]] = getValueOfStatus();
            } else {
                ret[pMasqueradingVector[3]] = Json::Value();
            }
        }
        if (!pMasqueradingVector[4].empty()) {
            if (getCreatedAt()) {
                ret[pMasqueradingVector[4]] = getCreatedAt()->toDbStringLocal();
            } else {
                ret[pMasqueradingVector[4]] = Json::Value();
            }
        }
        return ret;
    }
    LOG_ERROR << "Masquerade failed";
    if (getCandidateId()) {
        ret["candidate_id"] = getValueOfCandidateId();
    } else {
        ret["candidate_id"] = Json::Value();
    }
    if (getVacancyId()) {
        ret["vacancy_id"] = getValueOfVacancyId();
    } else {
        ret["vacancy_id"] = Json::Value();
    }
    if (getEmployerId()) {
        ret["employer_id"] = getValueOfEmployerId();
    } else {
        ret["employer_id"] = Json::Value();
    }
    if (getStatus()) {
        ret["status"] = getValueOfStatus();
    } else {
        ret["status"] = Json::Value();
    }
    if (getCreatedAt()) {
        ret["created_at"] = getCreatedAt()->toDbStringLocal();
    } else {
        ret["created_at"] = Json::Value();
    }
    return ret;
}

bool Responces::validateJsonForCreation(const Json::Value &pJson,
                                        std::string &err) {
    if (pJson.isMember("candidate_id")) {
        if (!validJsonOfField(0, "candidate_id", pJson["candidate_id"], err,
                              true))
            return false;
    } else {
        err = "The candidate_id column cannot be null";
        return false;
    }
    if (pJson.isMember("vacancy_id")) {
        if (!validJsonOfField(1, "vacancy_id", pJson["vacancy_id"], err, true))
            return false;
    } else {
        err = "The vacancy_id column cannot be null";
        return false;
    }
    if (pJson.isMember("employer_id")) {
        if (!validJsonOfField(2, "employer_id", pJson["employer_id"], err,
                              true))
            return false;
    } else {
        err = "The employer_id column cannot be null";
        return false;
    }
    if (pJson.isMember("status")) {
        if (!validJsonOfField(3, "status", pJson["status"], err, true))
            return false;
    }
    if (pJson.isMember("created_at")) {
        if (!validJsonOfField(4, "created_at", pJson["created_at"], err, true))
            return false;
    }
    return true;
}
bool Responces::validateMasqueradedJsonForCreation(
    const Json::Value &pJson,
    const std::vector<std::string> &pMasqueradingVector, std::string &err) {
    if (pMasqueradingVector.size() != 5) {
        err = "Bad masquerading vector";
        return false;
    }
    try {
        if (!pMasqueradingVector[0].empty()) {
            if (pJson.isMember(pMasqueradingVector[0])) {
                if (!validJsonOfField(0, pMasqueradingVector[0],
                                      pJson[pMasqueradingVector[0]], err, true))
                    return false;
            } else {
                err =
                    "The " + pMasqueradingVector[0] + " column cannot be null";
                return false;
            }
        }
        if (!pMasqueradingVector[1].empty()) {
            if (pJson.isMember(pMasqueradingVector[1])) {
                if (!validJsonOfField(1, pMasqueradingVector[1],
                                      pJson[pMasqueradingVector[1]], err, true))
                    return false;
            } else {
                err =
                    "The " + pMasqueradingVector[1] + " column cannot be null";
                return false;
            }
        }
        if (!pMasqueradingVector[2].empty()) {
            if (pJson.isMember(pMasqueradingVector[2])) {
                if (!validJsonOfField(2, pMasqueradingVector[2],
                                      pJson[pMasqueradingVector[2]], err, true))
                    return false;
            } else {
                err =
                    "The " + pMasqueradingVector[2] + " column cannot be null";
                return false;
            }
        }
        if (!pMasqueradingVector[3].empty()) {
            if (pJson.isMember(pMasqueradingVector[3])) {
                if (!validJsonOfField(3, pMasqueradingVector[3],
                                      pJson[pMasqueradingVector[3]], err, true))
                    return false;
            }
        }
        if (!pMasqueradingVector[4].empty()) {
            if (pJson.isMember(pMasqueradingVector[4])) {
                if (!validJsonOfField(4, pMasqueradingVector[4],
                                      pJson[pMasqueradingVector[4]], err, true))
                    return false;
            }
        }
    } catch (const Json::LogicError &e) {
        err = e.what();
        return false;
    }
    return true;
}
bool Responces::validateJsonForUpdate(const Json::Value &pJson,
                                      std::string &err) {
    if (pJson.isMember("candidate_id")) {
        if (!validJsonOfField(0, "candidate_id", pJson["candidate_id"], err,
                              false))
            return false;
    } else {
        err = "The value of primary key must be set in the json object for "
              "update";
        return false;
    }
    if (pJson.isMember("vacancy_id")) {
        if (!validJsonOfField(1, "vacancy_id", pJson["vacancy_id"], err, false))
            return false;
    } else {
        err = "The value of primary key must be set in the json object for "
              "update";
        return false;
    }
    if (pJson.isMember("employer_id")) {
        if (!validJsonOfField(2, "employer_id", pJson["employer_id"], err,
                              false))
            return false;
    }
    if (pJson.isMember("status")) {
        if (!validJsonOfField(3, "status", pJson["status"], err, false))
            return false;
    }
    if (pJson.isMember("created_at")) {
        if (!validJsonOfField(4, "created_at", pJson["created_at"], err, false))
            return false;
    }
    return true;
}
bool Responces::validateMasqueradedJsonForUpdate(
    const Json::Value &pJson,
    const std::vector<std::string> &pMasqueradingVector, std::string &err) {
    if (pMasqueradingVector.size() != 5) {
        err = "Bad masquerading vector";
        return false;
    }
    try {
        if (!pMasqueradingVector[0].empty() &&
            pJson.isMember(pMasqueradingVector[0])) {
            if (!validJsonOfField(0, pMasqueradingVector[0],
                                  pJson[pMasqueradingVector[0]], err, false))
                return false;
        } else {
            err = "The value of primary key must be set in the json object for "
                  "update";
            return false;
        }
        if (!pMasqueradingVector[1].empty() &&
            pJson.isMember(pMasqueradingVector[1])) {
            if (!validJsonOfField(1, pMasqueradingVector[1],
                                  pJson[pMasqueradingVector[1]], err, false))
                return false;
        } else {
            err = "The value of primary key must be set in the json object for "
                  "update";
            return false;
        }
        if (!pMasqueradingVector[2].empty() &&
            pJson.isMember(pMasqueradingVector[2])) {
            if (!validJsonOfField(2, pMasqueradingVector[2],
                                  pJson[pMasqueradingVector[2]], err, false))
                return false;
        }
        if (!pMasqueradingVector[3].empty() &&
            pJson.isMember(pMasqueradingVector[3])) {
            if (!validJsonOfField(3, pMasqueradingVector[3],
                                  pJson[pMasqueradingVector[3]], err, false))
                return false;
        }
        if (!pMasqueradingVector[4].empty() &&
            pJson.isMember(pMasqueradingVector[4])) {
            if (!validJsonOfField(4, pMasqueradingVector[4],
                                  pJson[pMasqueradingVector[4]], err, false))
                return false;
        }
    } catch (const Json::LogicError &e) {
        err = e.what();
        return false;
    }
    return true;
}
bool Responces::validJsonOfField(size_t index, const std::string &fieldName,
                                 const Json::Value &pJson, std::string &err,
                                 bool isForCreation) {
    switch (index) {
    case 0:
        if (pJson.isNull()) {
            err = "The " + fieldName + " column cannot be null";
            return false;
        }
        if (!pJson.isInt()) {
            err = "Type error in the " + fieldName + " field";
            return false;
        }
        break;
    case 1:
        if (pJson.isNull()) {
            err = "The " + fieldName + " column cannot be null";
            return false;
        }
        if (!pJson.isInt()) {
            err = "Type error in the " + fieldName + " field";
            return false;
        }
        break;
    case 2:
        if (pJson.isNull()) {
            err = "The " + fieldName + " column cannot be null";
            return false;
        }
        if (!pJson.isInt()) {
            err = "Type error in the " + fieldName + " field";
            return false;
        }
        break;
    case 3:
        if (pJson.isNull()) {
            return true;
        }
        if (!pJson.isString()) {
            err = "Type error in the " + fieldName + " field";
            return false;
        }
        if (pJson.isString() && std::strlen(pJson.asCString()) > 50) {
            err = "String length exceeds limit for the " + fieldName +
                  " field (the maximum value is 50)";
            return false;
        }

        break;
    case 4:
        if (pJson.isNull()) {
            return true;
        }
        if (!pJson.isString()) {
            err = "Type error in the " + fieldName + " field";
            return false;
        }
        break;
    default:
        err = "Internal error in the server";
        return false;
    }
    return true;
}
